
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "PluginMiniEditor.h"
#include "ssp/EditorHost.h"


// #define RNBO_NOSTL
// #define RNBO_USE_FLOAT32
#define RNBO_NOTHROW  // no exceptopns
// #define RNBO_USECUSTOMPLATFORM
#define RNBO_USECUSTOMPLATFORMPRINT
// #define RNBO_USECUSTOMALLOCATOR
#define RNBO_FIXEDLISTSIZE 64
#define RNBO_NO_PATCHERFACTORY


namespace RNBO {
namespace Platform {
static void printMessage(const char* message) {
}
static void printErrorMessage(const char* message) {
}
}  // namespace Platform
}  // namespace RNBO


// ignore warnings generated by rnbo export, outside our control
#pragma GCC diagnostic push
// #ifndef __clang__
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wswitch"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#pragma GCC diagnostic ignored "-Wunused-value"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wsuggest-override"
// #endif
#include "../__MOD__-rnbo/__MOD__.cpp.h"
#pragma GCC diagnostic pop



class RNBOPatch : public RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> {

};


inline float constrainFloat(float v, float vMin, float vMax) {
    return std::max<float>(vMin, std::min<float>(vMax, v));
}

inline float normValue(RangedAudioParameter &p) {
    return p.convertFrom0to1(p.getValue());
}



PluginProcessor::PluginProcessor()
    : PluginProcessor(getBusesProperties(), createParameterLayout()) {}

PluginProcessor::PluginProcessor(
    const AudioProcessor::BusesProperties &ioLayouts,
    AudioProcessorValueTreeState::ParameterLayout layout)
    : BaseProcessor(ioLayouts, std::move(layout)), params_(vts()) {
    init();
    rnbo_.pPatch_ = new RNBOPatch();
    rnbo_.pPatch_->initialize();

    rnbo_.nInputs_ = rnbo_.pPatch_->getNumInputChannels();
    rnbo_.inputBuffers_ = new RNBO::number *[rnbo_.nInputs_];
    for (int i = 0; i < rnbo_.nInputs_; i++) {
        rnbo_.inputBuffers_[i] = new RNBO::number[bufferSize_];
    }
    rnbo_.nOutputs_ = rnbo_.pPatch_->getNumOutputChannels();
    rnbo_.outputBuffers_ = new RNBO::number *[rnbo_.nOutputs_];
    for (int i = 0; i < rnbo_.nOutputs_; i++) {
        rnbo_.outputBuffers_[i] = new RNBO::number[bufferSize_];
    }

    rnbo_.nParams_ = params_.rnboParams_.size();
    rnbo_.lastParamVals_ = new float[rnbo_.nParams_];
    for (int i = 0; i < rnbo_.nParams_; i++) {
        rnbo_.lastParamVals_[i] = -1.0;
    }
}

PluginProcessor::~PluginProcessor() {
    for (int i = 0; i < rnbo_.nInputs_; i++) {
        delete rnbo_.inputBuffers_[i];
    }
    delete rnbo_.inputBuffers_;
    for (int i = 0; i < rnbo_.nOutputs_; i++) {
        delete rnbo_.outputBuffers_[i];
    }
    delete rnbo_.outputBuffers_;
    delete rnbo_.pPatch_;
}


juce::AudioProcessor::BusesProperties PluginProcessor::getBusesProperties() {
    juce::AudioProcessor::BusesProperties props;
    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
    unsigned I_MAX = patch.getNumInputChannels();
    for (auto i = 0; i < I_MAX; i++) {
        props.addBus(true, getInputBusName(i), AudioChannelSet::mono());
    }
    unsigned O_MAX = patch.getNumOutputChannels();
    for (auto i = 0; i < O_MAX; i++) {
        props.addBus(false, getOutputBusName(i), AudioChannelSet::mono());
    }
    return props;
}



PluginProcessor::RnboParam::RnboParam(AudioProcessorValueTreeState &apvt, StringRef id, unsigned idx) :
    id_(id), idx_(idx), val_(*apvt.getParameter(id)) {

    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
//    unsigned idx = rnboObj_.getParameterIndexForID(id_.c_str());
    desc_ = patch.getParameterName(idx_);
    RNBO::ParameterInfo info;

    patch.getParameterInfo(idx_, &info);
    min_=info.min;
    max_=info.max;
    steps_=info.steps;
    enumValues_ = info.enumValues != nullptr;
}


PluginProcessor::PluginParams::PluginParams(AudioProcessorValueTreeState &apvt) {
    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
    unsigned nParams = patch.getNumParameters();
    for (unsigned i = 0; i < nParams; i++) {
        RNBO::ParameterInfo info;
        String id = patch.getParameterId(i);
        patch.getParameterInfo(i, &info);
        if (info.visible) {
            rnboParams_.push_back(std::make_unique<RnboParam>(apvt, id, i));
        }
    }
}


AudioProcessorValueTreeState::ParameterLayout PluginProcessor::createParameterLayout() {
    AudioProcessorValueTreeState::ParameterLayout params;
    BaseProcessor::addBaseParameters(params);

    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
    unsigned nParams = patch.getNumParameters();
    for (unsigned pn = 0; pn < nParams; pn++) {
        String id = patch.getParameterId(pn);
        RNBO::ParameterInfo info;
        patch.getParameterInfo(pn, &info);
        if (info.visible) {
            String desc = info.displayName;
            if (desc.length() == 0) desc = patch.getParameterName(pn);

            if (info.enumValues) {
                juce::StringArray choices;
                for (unsigned i = 0; i < info.steps; i++) {
                    choices.add(info.enumValues[i]);
                }
                params.add(std::make_unique<ssp::BaseChoiceParameter>(id, desc, choices, info.initialValue));
            } else {
                if (info.steps < 2) {
                    params.add(std::make_unique<ssp::BaseFloatParameter>(id, desc, info.min, info.max, info.initialValue));
                } else if (info.steps == 2) {
                    params.add(std::make_unique<ssp::BaseBoolParameter>(id, desc, info.initialValue > 0.5f));
                } else {
                    float inc = (info.max - info.min) / (info.steps - 1);
                    params.add(std::make_unique<ssp::BaseFloatParameter>(id, desc, info.min, info.max, info.initialValue, inc));
                }
            }
        }
    }
    return params;
}

const String PluginProcessor::getInputBusName(int channelIndex) {
    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
    unsigned I_MAX = patch.getNumInputChannels();
    if (channelIndex < I_MAX) { return "In " + String(channelIndex); }
    return "ZZIn-" + String(channelIndex);
}


const String PluginProcessor::getOutputBusName(int channelIndex) {
    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch;
    patch.initialize();
    unsigned O_MAX = patch.getNumOutputChannels();
    if (channelIndex < O_MAX) { return "Out " + String(channelIndex); }
    return "ZZOut-" + String(channelIndex);
}

void PluginProcessor::prepareToPlay(double sampleRate, int samplesPerBlock) {
    BaseProcessor::prepareToPlay(sampleRate, samplesPerBlock);

    if (samplesPerBlock != bufferSize_) {
        bufferSize_ = samplesPerBlock;
        for (int i = 0; i < rnbo_.nInputs_; i++) {
            delete rnbo_.inputBuffers_[i];
            rnbo_.inputBuffers_[i] = new RNBO::number[bufferSize_];
        }
        for (int i = 0; i < rnbo_.nOutputs_; i++) {
            delete rnbo_.outputBuffers_[i];
            rnbo_.outputBuffers_[i] = new RNBO::number[bufferSize_];
        }
    }
    rnbo_.pPatch_->prepareToProcess(sampleRate, samplesPerBlock,true);
}

void PluginProcessor::processBlock(AudioSampleBuffer &buffer, MidiBuffer &midiMessages) {
    size_t n = buffer.getNumSamples();


    // set parameters up for patch, only set on change
    unsigned pi = 0;
    for (auto &p: params_.rnboParams_) {
        float val = p->val_.getValue();
        if (rnbo_.lastParamVals_[pi] != val) {
            rnbo_.pPatch_->setParameterValue(p->idx_, normValue(p->val_),RNBO::TimeNow);
            rnbo_.lastParamVals_[pi] = val;
        }
        pi++;
    }
    // later can perhaps use vector copies?
    {
        // process input
        for (unsigned c = 0; c < rnbo_.nInputs_; c++) {
            for (unsigned i = 0; i < n; i++) {
                rnbo_.inputBuffers_[c][i] = buffer.getSample(c, i);
            }
        }
    }
    rnbo_.pPatch_->process(rnbo_.inputBuffers_, rnbo_.nInputs_, rnbo_.outputBuffers_, rnbo_.nOutputs_, bufferSize_);

    {
        // copy output
        for (unsigned c = 0; c < rnbo_.nOutputs_; c++) {
            for (unsigned i = 0; i < n; i++) {
                buffer.setSample(c, i, rnbo_.outputBuffers_[c][i]);
            }
        }
    }

}

AudioProcessorEditor *PluginProcessor::createEditor() {
#ifdef FORCE_COMPACT_UI
    return new ssp::EditorHost(this, new PluginMiniEditor(*this),true);
#else
    if (useCompactUI()) {
        return new ssp::EditorHost(this, new PluginMiniEditor(*this), useCompactUI());

    } else {
        return new ssp::EditorHost(this, new PluginEditor(*this, (params_.rnboParams_.size() / 16) + 1),useCompactUI());
    }
#endif
}

AudioProcessor *JUCE_CALLTYPE createPluginFilter() {
    return new PluginProcessor();
}


